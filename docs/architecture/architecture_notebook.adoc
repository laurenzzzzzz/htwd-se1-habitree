= Architecture Notebook: {project-name}
Laurenz Born <laurenz.born@stud.htw-dresden.de>; Alexander Chlebowski <alexander.chlebowski@stud.htw-dresden.de>; Leonhard Hermann <leonhard.hermann@stud.htw-dresden.de>; Johann Schmidt <johann.schmidt@stud.htw-dresden.de>; Kimi Jerke <kimi.jerke@stud.htw-dresden.de>; Jannes Lehmann <s86317@htw-dresden.de>
{localdatetime}
include::../_includes/default-attributes.inc.adoc[]


== Zweck
Dieses Dokument beschreibt die Philosophie, Entscheidungen, Nebenbedingungen, Begründungen, wesentliche Elemente und andere übergreifende Aspekte des Systems, die Einfluss auf Entwurf und Implementierung haben.



== Architekturziele 

Die Architektur der Habit-Tracking-App verfolgt das Ziel, eine robuste, nutzerfreundliche und wartbare mobile Anwendung bereitzustellen. Sie muss auch unter mobilen Bedingungen zuverlässig funktionieren, idealerweise inklusive Offline-Nutzung, sicherem Umgang mit Nutzerdaten und reibungsloser Benutzererfahrung. Im Fokus stehen dabei folgende zentrale Ziele:

* **Performance**
** *Geringe Latenz bei UI-Interaktionen:* Die App soll möglichst sofort auf Benutzereingaben reagieren, ohne Ruckler beim Scrollen oder Wechseln zwischen Ansichten.
** *Schnelle Ladezeiten:* Daten sollen lokal vorgehalten oder effizient über das Netzwerk geladen werden.

* **Zuverlässigkeit**
** *Robuste Services:* Bei Dienstausfällen auf Serverseite (z. B. Neustarts) darf es nicht zu sehr langfristigen Funktionsverlust kommen.
** *Health-Checks und Rollback:* Wünschenswert wäre, dass das System  bei Inkonsistenzen in Datenbeständen o. ä. automatisch einen Rollback durchführen bzw. diese behebt.

* **Sicherheit**
** *Authentifizierung:* Nutzerregistrierung und -login sollen über ein sicheres Auth-System einerfolgen.
** *Datenverschlüsselung:* Sensible Daten (z. B. persönliche Gewohnheiten) werden sicher gespeichert.
** *Anmeldung & Sessions:* Nutzer bleiben über Sessions angemeldet.

* **Portabilität**
** *Gemeinsame Code-Basis (Android & iOS):* Pflege einer einzigen Codebasis für beide Plattformen. (Auch wenn sich der Fokus im Rahmen des Moduls aus zeitgründen auf der Entwicklung der iOS Version fokussiert)
** *Plattformunabhängige Schnittstellen* 

* **Echtzeit-Updates**
** *Aktuelle Anzeige von Status & Logs:* Änderungen (z. B. „Habit abgehakt“) sollen unmittelbar im UI sichtbar sein – ggf. über Polling oder Push-Ansätze.

* **Wartbarkeit**
** *Modularität:* Sauber getrennte Komponenten und Services erleichtern Weiterentwicklung.
** *Dokumentation:* Saubere Schnittstellen und Struktur fördern Problemlösungen bei Fehlern und Ergänzungen leichter zu implementieren. 

* **Skalierbarkeit**
** *Horizontale Skalierung:* bei Nutzerwachstum
** *Effiziente Datenbank* 



== Annahmen und Abhängigkeiten
* Zugriff auf eigenen Server.
* Die App wird als mobile Anwendung umgesetzt, welche iOS (und Android zweitrangig) unterstützen soll.
* Die Zielgruppe sind vor allem Einzelpersonen, die persönliche Routinen tracken wollen, eine Mehrbenutzerfähigkeit (z.B. Teams oder Gruppenfunktionen) ist  nicht vorgesehen.
* Die initiale Entwicklung erfolgt durch ein kleines Team mit begrenzter Programmiererfahrung, daher sind einfache Tools, gute Dokumentation und Typsicherheit wichtig.
//* Es ist vorgesehen, dass die App offlinefähig ist mittels lokalem Caching und späterer Synchronisation.
* Datenschutz ist wichtig: DSGVO-Konformität sollte berücksichtigt werden, weshalb persönliche Daten sicher gespeichert werden müssen und auf Wunsch vollständig löschbar sind.
* Benutzerverwaltung und Authentifizierung werden selbst entwickelt.
* Das Backend wird auf einem selbstverwalteten Server betrieben – eigene Datenbank zur Speicherung der Nutzdaten der jeweiligen Nutzer (Fortschritte etc.).
* Die App setzt keine Legacy-Systeme oder bestehende Datenbanken voraus, da es sich um eine Neuentwicklung ohne Altsystem handelt.
* Die geplanten Nutzerzahlen sind zunächst gering, was anfangs keine groß skalierte Architektur und vorallem Serverinfrastruktur voraussetzt. Trotzdem soll die Infastruktur so ausgerichtet sein, dass diese mit steigender Nutzerzahl technisch leicht skalierbar ist.
* Für den Anfang bestehen erstmal keine besonderen Anforderungen an spezielle Hardware-Sensoren oder Hintergrunddienste (z.B. HealthKit, Schrittzähler).  Erweiterungen sind aber technisch denkbar.
* Push-Benachrichtigungen oder Reminder sind im MVP (Minimum Viable Product) vorgesehen.
* Anfängliche Überlegungen zur Nutzung von R für die Erstellung von statisitischen Grafiken wurden aufgrund von Implementierungsaufwand verworfen. 

== Architektur-relevante Anforderungen

* Das System muss eine persistente Speicherung von Nutzerdaten und Habit-Daten ermöglichen.
* Die Anwendung muss Nutzerregistrierung und -authentifizierung unterstützen.
* Es muss eine sichere Speicherung sensibler Daten (z. B. Passwörter) gewährleistet sein.
* Die Architektur muss eine mobile Anwendung unterstützen.
* Die Lösung muss modular aufgebaut sein, um eine Trennung zwischen Präsentation, Logik und Datenzugriff zu ermöglichen.
* Es muss eine Schnittstelle zur Kommunikation zwischen Frontend und Backend bereitgestellt werden 
* Die Architektur soll wartbar und erweiterbar sein.

== Entscheidungen, Nebenbedingungen und Begründungen


=== Frontend-Technologie: Expo (React Native)

*Begründung:* +
- Plattformübergreifende Entwicklung (iOS & Android) mit gemeinsamer Codebasis +
- Live-Testing auf echter Hardware über *Expo Go* per QR-Scan +
- Schnelles Debugging & Hot Reloading +
- Nutzung vertrauter Webtechnologien (JavaScript / TypeScript) +
- Keine macOS-Umgebung notwendig → Entwicklung auf Windows möglich +
- Unterstützt JSON-basierte Konfiguration und lokalen Speicher +

*Nebenbedingung:* +
- Expo-App muss auf Testgeräten installiert sein, um Builds zu starten +
- Komplexe native Module sollten vermieden werden +

---

=== Alternative bewertet: Flutter (Nicht verwendet)

*Begründung für Verwerfung:* +
- Nur virtuelle Testumgebung, kein direkter Test auf physischer Hardware +
- Hoher Speicherverbrauch & Overhead für kleines Projekt +
- Eingeschränkte Drittanbieterbibliotheken +
- Für kleine studentische Teams mit kurzen Iterationszyklen ungeeignet +

---

=== Backend-Technologie: Node.js mit Express

*Begründung:* +
- Einheitliche Sprache (JavaScript) für Frontend & Backend +
- geringere Einarbeitungszeit +
- Bekannte Syntax aus vorherigen Modulen (z. B. EWA) +
- Schnelle Erstellung von REST-Endpunkten +
- Hohe Community-Unterstützung und viele verfügbare Bibliotheken +
- Einfache Integration von **node-cron** für zeitgesteuerte Hintergrundaufgaben (z. B. tägliche Routinen) +

*DO:* +
- Standardisierte Routenstruktur (z. B. `/habits`, `/users`, `/achievements`)  

---

=== Datenbank: PostgreSQL (mit Prisma ORM)

*Begründung:* +
- Zuverlässige relationale Datenbank für strukturierte Daten (User, Habits, Achievements) +
- Unterstützt zeitbasierte Abfragen (z.B.: „Habits im letzten Monat“) +
- Prisma ORM bietet Typsicherheit, Migrationen und abstrahiertes Datenbank-Management +
- Vereinfachte Integration mit Express / Node.js +

*Nebenbedingung:* +
- Datenmodelle werden zentral über Prisma-Schema gepflegt +
- Migrationsänderungen dokumentieren und im Repository versionieren +

---

=== Authentifizierung: Firebase Auth (nichtmehr verwendet)


*Begründung für die Entfernung von Firebase Auth:* +
- Aufgrund von Kompatibilitätsproblemen mit der EXPO GO APP unter iOS kann Firebase Auth leider nicht im Rahmen unserer Entwicklung weiter verwendet werden und wurde durch eine eigenes entwickelte Authentifizierungslösung ersetzt.

[.deprecated]
====
*Ursprüngliche Begründung für Nutzung von Firebase Auth:*

*Begründung:*  +
- Sichere und skalierbare Lösung mit minimalem Implementierungsaufwand  +
- Unterstützt 2-Faktor-Authentifizierung, Social Logins und Passwort-Reset +
- Spart Entwicklungszeit, da keine eigene Authentifizierungslogik nötig ist +

====
---
=== Internationalisierung (i18next) 

_Status: Geplantes Feature._

*Begründung:* +
- Kompatibel mit React Native +
- Einfache JSON-basierte Übersetzungsstruktur +
- Skalierbar für zukünftige Sprachen und Erweiterungen +

*Nächste Schritte:* +
- i18next-Setup im Presentation-Layer verdrahten +
- Übersetzungsdateien für Deutsch/Englisch anlegen +

---

=== Offline-Funktionalität

_Status: Geplantes Feature – derzeit nur Auth-Tokens werden lokal zwischengespeichert._

*Begründung:* +
- Nutzer sollen Gewohnheiten auch ohne Internetverbindung (z. B. im Flugmodus) erfassen können +
- Verwendung lokaler Speicherung (*AsyncStorage* / JSON) zur Synchronisation mit dem Backend bei Wiederverbindung +
- Stellt sicher, dass Eingaben nicht verloren gehen, wenn kurzfristig keine Verbindung besteht +

*Nächste Schritte:* +
- Persistente Cache-Schicht für Habits & Streaks aufbauen +
- Konfliktauflösungskonzept für spätere Synchronisierung definieren +

---

=== Deployment & Entwicklungsumgebung

*Problem:* +
- Native Entwicklung (Swift/Xcode oder Kotlin/Android Studio) war aufgrund fehlender macOS- bzw. Android-Hardware nicht praktikabel +
- Testen auf echten Geräten wäre nur eingeschränkt möglich +

*Entscheidung:* +
- Nutzung von *Expo* für Frontend-Entwicklung und Testing auf echter Hardware +
- Backend läuft auf bereitgestelltem Windows-Server, wodurch kein lokaler Rechner dauerhaft aktiv sein muss +

*Vorgehensweise:* +
- Express.js-Server aufgesetzt und über *Prisma* an *PostgreSQL* angebunden +
- Kommunikation erfolgt über REST-API (Backend URL zentral konfiguriert in `constants/ApiConfig.ts`) +
- *Firebase Auth* war hier ursprünglich vorgesehen, ist aber verworfen (siehe Abschnitt "Authentifizierung") +
- Setup wurde dokumentiert, sodass Teammitglieder es lokal reproduzieren und erweitern +

---

=== Containerisierung: Docker & Development Container

*Begründung:* +
- *Konsistente Entwicklungsumgebung:* Der Dev Container (`.devcontainer/Dockerfile`) stellt sicher, dass alle Entwickler, unabhängig vom Host-Betriebssystem (Windows, macOS, Linux), in einer identischen Umgebung arbeiten.
- *Keine lokalen Installationen notwendig:* Node.js, npm, Git und weitere Tools sind bereits im Container vorhanden. Entwickler müssen diese nicht manuell installieren – nur Docker und VS Code sind erforderlich.
- *Automatischer Setup beim Containerstart:* Das `devcontainer.json`-Konfigurationsfile startet automatisch `npm ci`, installiert Expo-Dependencies und bootet den Expo-Dev-Server mit `npx expo start`.
- *Schnelle Onboarding:* (Neue) Entwickler können sofort produktiv arbeiten, ohne komplexe lokale Setups durchführen zu müssen.
- *Isolierte Abhängigkeiten:* Mehrere Projekte z.B. im Rahmen anderer Module bzw. Veranstaltungen können parallel entwickelt werden, ohne dass Versionskonflikte von Node.js, npm oder anderen Tools entstehen.

*Was läuft im Container:* +
Das Dockerfile basiert auf dem offiziellen `node:20-slim`-Image und enthält:

- **Node.js 20:** Basis für die Expo-App und Backend-Entwicklung
- **npm-Toolchain:** Mit zusätzlich installierten Build-Tools (g++, make, python3) für native Abhängigkeiten
- **Expo Dev Server:** Wird beim Containerstart automatisch gestartet und läuft auf Port `8081`
- **Development-Tools:** Git, ca-certificates und weitere Utilities für die Entwicklung
- **Umgebungsvariablen:** EXPO_DEV_SERVER_LISTEN_HOST=0.0.0.0 für Zugriff von außen, EXPO_NO_TELEMETRY=1 zur Deaktivierung von Telemetrie

Exponierte Ports:
- `8081`: Expo Dev Server (Hauptentwicklungsserver)
- `19000, 19001, 19002, 19006`: Zusätzliche Expo-Ports für Tunnel, Debugging und Metro Bundler

*Rollen in der Architektur:* +
- **Frontend-Entwicklung:** Der Dev Container ist primär für die Expo-Frontend-Entwicklung ausgelegt. Entwickler können die React Native App im Container entwickeln und über Expo Go oder einen Tunnel auf ihrem Gerät testen.
- **Integration mit VS Code:** Das `devcontainer.json` integriert den Container nahtlos mit VS Code, mit vordefinierten Extensions (ESLint, GitHub Copilot Chat, Prettier) und automatischem Port-Forwarding.

*Nebenbedingung:* +
- Docker und Docker Desktop müssen installiert sein +
- Initiales Setup beim ersten Container-Start dauert länger (npm ci, Expo-Installation)
- Container benötigt angemessene Hardware-Ressourcen 

*Nächste mögliche Schritte:* +
- Bei Bedarf Backend und Datenbank als separate Services in Docker definieren (docker-compose.yml für lokale Entwicklung) +
- Deployment-Container für Backend-Produktion separat konfigurieren +


== Schichten oder Architektur-Framework

=== Clean Code Prinzipien & Code Conventions 
Die Codebasis folgt konsequent einer Domain-Driven-Design-Struktur (DDD) und wendet etablierte Clean-Code-Prinzipien an:

* **Separation of Concerns (SoC) & Schichtenarchitektur**
** *Was:* Trennung des Codes in logische Schichten mit klaren Zuständigkeiten.
** *Wie:* Aufteilung in Domain (Logik), Application (Use Cases), Infrastructure (Datenzugriff) und Presentation (UI).
** *Wo:* Sichtbar in der Ordnerstruktur `src/habitree/` (`domain/`, `application/`, `infrastructure/`, `presentation/`).

* **Meaningful Names (Sprechende Namen)**
** *Was:* Klassen, Methoden und Variablen beschreiben ihre Funktion eindeutig.
** *Wie:* Verzicht auf generische Namen, Nutzung von Verben für Aktionen und Substantiven für Objekte.
** *Wo:* `HabitService.ts` (Methoden wie `toggleHabit`), `authMiddleware.js` (Funktion `verifyJwtToken`), `Habit.ts` (Eigenschaften wie `isHarvested`).

* **Single Responsibility Principle (SRP)**
** *Was:* Jede Klasse oder jedes Modul hat nur einen Änderungsgrund bzw. eine Aufgabe.
** *Wie:* Auslagerung von Styles, Trennung von UI-Darstellung, Logik und Datenzugriff.
** *Wo:* `HabitList.tsx` kümmert sich nur um die Darstellung, `HabitList_style.ts` um das Design und `HabitService.ts` um die Logik.

* **Encapsulation & Immutability**
** *Was:* Schutz von Daten vor ungewollter Änderung und Kapselung von Geschäftsregeln.
** *Wie:* Verwendung von `readonly`-Eigenschaften in Entitäten.
** *Wo:* Domain Entities wie `Habit.ts` (`readonly id`, `readonly name`).

* **Dependency Inversion Principle (DIP)**
** *Was:* High-Level-Module hängen von Abstraktionen ab, nicht von Details.
** *Wie:* Services nutzen Interfaces (Ports) anstelle von konkreten Implementierungen.
** *Wo:* `HabitService` nutzt `IHabitsRepository` (Interface), wodurch die Datenquelle (API, Local Storage) austauschbar ist.

* **Error Handling & Fail-Fast**
** *Was:* Sauberes Abfangen und Behandeln von Fehlern, um inkonsistente Zustände zu vermeiden.
** *Wie:* Konsistente Nutzung von Try-Catch-Blöcken und HTTP-Statuscodes.
** *Wo:* Backend-Routen (`routes/habits.js`) und Middleware (`authMiddleware.js`).

* **Code-Standards & Formatierung**
** *Was:* Einhalten eines einheitlichen Code-Stils im Team.
** *Wie:* Code Konventionen
*** **Dateinamen:**
**** React-Komponenten: PascalCase (z. B. `HabitList.tsx`)
**** Hooks/Funktionen: camelCase (z. B. `useAuth.ts`, `streak.ts`)
**** Klassen/Typen: PascalCase (z. B. `Habit.ts`)
*** **Code:**
**** Variablen/Methoden: camelCase (z. B. `toggleHabit`, `isHarvested`)
**** Interfaces: PascalCase, teils mit Prefix 'I' (z. B. `IHabitsRepository`)
**** Komponenten: PascalCase (z. B. `function HabitList(...)`)



=== Architektur auf einen Blick

[cols="1,2,2",options="header"]
|===
| Layer | Beschreibung | Beispiele
| Presentation Layer | Visualisiert Informationen und ermöglicht Nutzereingaben (UI) | [presentation/controllers/useHabitsController.tsx], [presentation/ui/HabitList.tsx], [app/_layout.tsx]
| Service Layer | Orchestriert Anwendungsabläufe mit Hilfe der Fachobjekte | [application/services/HabitService.ts], [application/services/AuthService.ts]
| Domain Layer | Enthält fachliche Regeln und den Zustand der Geschäftsobjekte | [domain/entities/Habit.ts], [domain/entities/User.ts], [domain/repositories/IHabitsRepository.ts]
| Infrastructure Layer | Liefert technische Basis für Persistenz, Kommunikation und Sicherheit | [infrastructure/adapters/ApiHabitsRepository.ts], [infrastructure/adapters/SecureStoreAuthRepository.ts], [infrastructure/di/ServiceContainer.ts]
|===

=== Ordnerstruktur (Top-Level src/habitree)

----
src/habitree/
├── domain/              # Entitäten + Repository-Schnittstellen
├── application/         # Services
├── infrastructure/      # Adapter + Dependency Injection
├── presentation/        # Provider, Controller-Hooks, UI
├── app/                 # Expo Router Screens
├── context/             # AuthContext & globale Provider
├── constants/, hooks/, styles/, assets/
----

=== Layer-Verantwortlichkeiten im Detail

==== Domänenschicht – domain/
* **entities/** – Enthält alle Fachobjekte wie [/domain/entities/Habit.ts], [/domain/entities/User.ts] oder [/domain/entities/Entry.ts]. Hier werden Berechnungen (z. B. Streak), Validierungen und der Zustand der Geschäftsobjekte definiert.
* **repositories/** – Beinhaltet die Repository-Schnittstellen, etwa [/domain/repositories/IHabitsRepository.ts], [/domain/repositories/IAuthRepository.ts] oder [/domain/repositories/IAchievementRepository.ts]. Diese Interfaces beschreiben, welche Datenzugriffe ein Service benötigt.
* **ports/** – Zusätzliche Schnittstellen zu technischen Diensten wie Benachrichtigungen (siehe [/domain/ports/INotificationPort.ts]). Dient als Erweiterungspunkt für nicht-datenbankbezogene Abhängigkeiten.
* **policies/** – Bündelt fachliche Regeln, die nicht zu einer einzelnen Entity gehören, z. B. [/domain/policies/HabitSchedulePolicy.ts] für Wiederholungslogik und Payload-Validierung vor der Persistenz.
* **Regeln:** Die Domäne importiert ausschließlich Standard-TypeScript, keinerlei Frameworks. HTTP, Persistenz oder UI sind an dieser Stelle unbekannt.

==== Anwendungsschicht (Service Layer) – application/
* **services/** – Enthält Use-Case-spezifische Koordinatoren wie [/application/services/AuthService.ts], [/application/services/HabitService.ts], [/application/services/QuoteService.ts] und [/application/services/ProfileService.ts]. Sie orchestrieren mehrere Ports und kapseln Fehlerbehandlung sowie Domänenlogik.
* **types/** – Gemeinsame Typsammlungen wie [/application/types/ApplicationServices.ts], die der Präsentationsschicht beschreiben, welche Services via DI verfügbar sind.
* **Regeln:** Services sind zustandslos, greifen nur über Interfaces auf Infrastruktur zu und enthalten keine UI-spezifischen Details.

==== Infrastruktur – infrastructure/
* **adapters/** – Technische Implementierungen der Domänenports, etwa [/infrastructure/adapters/ApiHabitsRepository.ts] für REST-Kommunikation oder [/infrastructure/adapters/SecureStoreAuthRepository.ts] für lokale Speicherung. Jeder Adapter kümmert sich um HTTP-Header, Tokenverwaltung, Fehlerbehandlung und wandeln einfache Transportdaten (DTOs) in Domänenobjekte um.
* **di/** – Der ServiceContainer [/infrastructure/di/ServiceContainer.ts] erstellt sämtliche Adapter und Services einmal zentral und stellt sie  der App bereit.
* **Regeln:** Neue externe Systeme (Push, Analytics, weitere Endpoints) landen immer zuerst als Adapter. Nur der Service-Container verdrahtet konkrete Implementierungen mit Interfaces.

==== Präsentationsschicht – presentation/
* **providers/** – Beispielsweise [/presentation/providers/ApplicationServicesProvider.tsx] veröffentlichen die Services im React-Kontext und bilden die Brücke zum Expo Router.
* **controllers/** – Hooks wie [/presentation/controllers/useAuthController.tsx] oder [/presentation/controllers/useHabitsController.tsx] kapseln UI-Status, Loading/Error-Handling und delegieren an die Anwendungsschicht.
* **ui/** – Präsentationskomponenten wie [/presentation/ui/HabitList.tsx], [/presentation/ui/QuoteBanner.tsx] oder generische Bausteine (ThemedView, Collapsible). Sie enthalten keine Geschäftslogik und reagieren ausschließlich auf Props.
* **Regeln:** Keine direkten Infrastrukturimporte; sämtliche Abhängigkeiten werden über `useApplicationServices()` oder Controller-Hooks gedeckt.

==== Expo Router & Kontext – app/, context/
* **app/** – Enthält die Expo-Router-Struktur: Layout ([/app/_layout.tsx]), Auth-Stack ([/app/(auth)/login.tsx]) und Tab-Navigation ([/app/(tabs)/index.tsx]). Jeder Screen nutzt Controller-Hooks, um sich mit der Anwendungsschicht zu verbinden.
* **context/** – Der globale AuthContext ([/context/AuthContext.tsx]) kombiniert `AuthService` mit dem SecureStore-Adapter, speichert Token/User und stellt `signIn/signOut` für alle Screens bereit.
* **Regeln:** `ApplicationServicesProvider` und `AuthProvider` umschließen das gesamte Router-Layout, sodass alle Screens denselben Service-Container nutzen.

=== Arbeitsprinzipien

* Abhängigkeiten verlaufen stets von Präsentation → Anwendung → Domäne; Infrastruktur implementiert nur Schnittstellen der domäne.
* Backend-Endpoints (`/auth`, `/habits`, `/profile`, `/quotes`, `/streaks`, `/achievements`) werden ausschließlich über Infrastrukturadapter adressiert.

=== Feature-Workflow

1. **Domäne:** Entität oder Repository-Schnittstelle ergänzen.
2. **Infrastruktur:** Adapter implementieren.
3. **Anwendung:** Service erweitern und im `ServiceContainer` registrieren.
4. **Präsentation:** Controller-Hook + UI/Screen ergänzen.
5. **Tests:** Unit-Tests für Services, Integrationstests für Adapter, UI-Tests für Komponenten.


== Architektursichten (Views)

Zur besseren Kommunikation und Dokumentation der Architektur werden folgende Sichten genutzt:

* **Kontextsicht:** Darstellung der wichtigsten externen Akteure (z. B. Benutzer) und deren Beziehung zum System. Zeigt, in welchem Umfeld sich die App bewegt.
* **Bausteinsicht:** Zeigt die interne Struktur der Anwendung auf Modulebene – z. B. Trennung von Komponenten, Services, Routen und Datenzugriff.
* **Laufzeitsicht:** Veranschaulicht typische Abläufe wie die Erstellung eines Habits oder das Abrufen von Logs – wichtig zur Analyse von Performance und Nebenläufigkeit.
* **Verteilungssicht:** Zeigt, welche Teile des Systems wo laufen – z. B. Backend auf eigenem Server, Datenbank auf dediziertem Datenbankserver, Frontend auf mobilen Geräten.

Weitere optionale Sichten (nur bei Bedarf):
* **Sicherheitssicht:** Welche Schutzmaßnahmen greifen wo (z. B. Authentifizierung, Datenverschlüsselung)?
* **Entwicklungssicht:** Projektstruktur, CI/CD-Prozesse, Deployment-Pipeline.

=== Kontextabgrenzung
//Level 1 im C4-Modell
//image::c4-habitree-level1.png[]
[plantuml]
....
include::plantuml/c4-habitree-level1.plantuml[]
....
Das C4-Level-1-Diagramm zeigt das Kontextdiagramm der App „Habitree“, einer Habit-Tracking-App zur Förderung positiver Gewohnheiten. Es stellt die wichtigsten Stakeholder, deren Rollen sowie deren Beziehungen zum System und zur Projektgruppe dar.


=== Container
//Level 2 im C4-Modell
//image::C4-level2.png[]
[plantuml]
....
include::plantuml/c4-habitree-level2.plantuml[]
....
Das C4-Level-2-Container-Diagramm zeigt die technische Struktur der Habitree-Anwendung auf Container-Ebene.

* Die Mobile App, das Frontend programmiert mit React Native, wird direkt von den Studierenden genutzt
* Das Backend basiert auf Node.js mit Express und läuft auf einem externen Server der Hochschule
* Zur Nutzer-Authentifizierung wird auf das Backend zugegriffen.
* Prisma ORM dient als Vermittler zwischen dem Backend und der PostgreSQL-Datenbank, in der Nutzerdaten und Gewohnheiten gespeichert werden
* Die Kommunikation zwischen Frontend und Backend erfolgt über eine REST API.

=== Components
//Level 3 im C4-Modell
[plantuml]
....
include::plantuml/c4-habitree-level3.plantuml[]
....

Das C4-Level-3-Komponentendiagramm detailliert die internen Bausteine der Habitree-Plattform:

* **Mobile App (Expo/React Native):** Expo Router & Screens kümmern sich um die Navigation. Controller-Hooks halten UI-Zustand und Validierung im Griff und rufen bei Bedarf die Application Services auf. Der ApplicationServicesProvider teilt die Services per React Context, der AuthContext merkt sich Token und Nutzerinfos. Domain-Klassen bleiben ohne Framework-Abhängigkeiten und sprechen über einfache Adapter (REST-Repos, SecureStore) mit der Technik. Der ServiceContainer steckt alle Teile einmal zentral zusammen.
* **Backend API (Node.js/Express):** `index.js` hängt die Routen und Middleware ein und startet einen kleinen node-cron-Job. Die einzelnen Router (`/auth`, `/habits`, `/user`, `/quotes`) laufen hinter der JWT-Middleware. Unsere Hilfsfunktionen (`generateDailyEntries`, `streak`) werden entweder vom Cronjob nachts oder manuell über REST angestoßen und kümmern sich um tägliche Einträge und Streaks. Der Prisma Client erledigt alle Datenbankzugriffe.
* **Persistenz:** Alle Komponenten interagieren ausschließlich über Prisma mit der PostgreSQL-Datenbank; dadurch bleibt die Trennung zwischen Domain-Logik und Infrastruktur gewahrt.

=== Verteilungsdiagramm (Deployment Diagramm)
image::deployment-diagram-habitree.svg[]



== Software-Dokumentation

* **Frontend-Code-Doku (TypeDoc):** Unter `docs/development/frontend/index.html` liegt die generierte HTML-Dokumentation der React-Komponenten, Controller und Provider. 
Regeneration bei Codeänderungen: 
im Verzeichnis `src/habitree` 
`npx typedoc --out ../../docs/development/frontend/ --entryPointStrategy expand --exclude "**/node_modules/**" --exclude "**/*.test.ts" --exclude "**/__tests__/**" --excludeExternals --excludePrivate --excludeProtected .` ausführen.

* **Backend-Code-Doku (JSDoc):** Unter `docs/development/backend/index.html` liegt die generierte HTML-Dokumentation der Express-Routen, Middleware und Utils. 
Regeneration bei Codeänderungen: 
im Verzeichnis `src/backend` 
`npx jsdoc -c jsdoc.json` ausführen.


//Muss das überhaupt hier rein??? ////
== Potenzielle Fehlerszenarien

* Keine Internetverbindung (z. B. HTW-Netz/VPN-Anforderungen) +
* Server-/Datenbankausfälle +
* Datenpersistenzfehler +
* Fehlende Push-Benachrichtigungen +
* Falsche Erinnerungszeiten oder Zeitzonenfehler +
* Fehlerhafte Baumvisualisierung +

== Glossar für technische Fachbegriffe
[%header]
|===
| Begriff | Definition/Erläuterung 
| Emulator | Ein Emulator ist eine Software, die auf einem Computer die Hardware und das Betriebssystem eines anderen Geräts nachahmt, um darauf Programme auszuführen.
| XCode |  integrierte Entwicklungsumgebung (IDE) von Apple zum Programmieren, Testen und Veröffentlichen von Apps für iOS, macOS, watchOS und tvOS.
| Swift | Programmiersprache zur Erstellung von Apps für iOS, macOS, watchOS und tvOS.
| Flutter | Flutter ist ein Open-Source-Framework von Google zur Entwicklung plattformübergreifender Apps für iOS, Android, Web und Desktop mit einer einzigen Codebasis in der Programmiersprache Dart.
| React Native | Framework zur Entwciklung von mobilen Applikationen für IOS und Android
| Expo | open source Platform für die entwicklung nativer apps für Andoiid, IOS und Web auf einer Codebasis in der Programmiersprache Typescript
| Expo Go | App auf mobilen Endgerät zur darstellung des entwickeltem Projects
| Ausfallzeit (engl.: Downtime)
| Zeitspanne, in der System nicht verfügbar oder funktionsfähig ist.  +
Kann verursacht werden Beispielsweise durch:  +
- Serverprobleme  +
- Bugs  +
- Wartung   
| Lightmode bzw. Darkmode 
| Darstellungsmodus einer Anwendung mit heller bzw. dunkler Benutzeroberfläche, meisten mit dunklen bzw. hellen Text auf hellen bzw. dunklen Hintergrund.  +
Das Ziel des Lightmodes ist es den Nutzer ein angenehmes feeling auch bei Tageslicht zu geben.  +
Die  Ziele des Darmodes sind primär die Entlastung der Augen und die Erhöhung der Energieeffizienz.
|Backend| Der Teil einer Anwendung, der auf dem Server läuft und Daten verarbeitet
|Frontend| Die Benutzeroberfläche einer Anwendung, die im Browser oder auf dem Gerät sichtbar ist
|API| Eine Schnittstelle, die den Datenaustausch zwischen verschiedenen Softwarekomponenten ermöglicht
|ORM|  Ein Werkzeug, das Datenbanktabellen in Programmiersprachenobjekte übersetzt und deren Nutzung vereinfacht
|Relationale Datenbank|  Eine Datenbank, die Daten in Tabellen mit Beziehungen zueinander speichert
|Framework| Ein vorgefertigtes Softwaregerüst, das Entwicklern beim Erstellen von Anwendungen hilft
|MVP (Minimum Viable Product)|Minimal umsetzbare Produktversion mit Kernfunktionen zur Validierung des Konzepts
|Domain-Driven Design (DDD)|Architekturstil, der Geschäftslogik in Domänenmodell, Anwendung, Infrastruktur und Präsentation trennt und Fachsprache mit Code synchron hält
|Repository|Abstraktion des Datenzugriffs, die Entitäten unabhängig von konkreten Speichertechnologien bereitstellt
|Port|Schnittstelle zu externen Diensten (z. B. Notifications), damit die Domäne keine technischen Details kennen muss
|Policy|Bündelt fachliche Regeln, die nicht zu einer einzelnen Entität gehören, etwa Zeit- oder Wiederholungslogik
|Adapter|Konkrete Implementierung eines Ports, die HTTP, lokale Speicherung oder andere Technik mit der Domäne verbindet
|Dependency Injection (DI)|Muster, bei dem Abhängigkeiten von außen bereitgestellt werden, um Code testbar und entkoppelt zu halten
|Composition Root|Zentraler Ort (z. B. ServiceContainer), an dem alle konkreten Implementierungen registriert und miteinander verdrahtet werden
|Expo Router|Dateibasiertes Routing-System von Expo/React Native zur Strukturierung von Screens, Layouts und Navigations-Stacks
|Controller-Hook|Präsentationsspezifischer Hook, der UI-Zustand, Validierung und Service-Aufrufe kapselt
|Provider|React-Komponente, die Werte oder Services über Context an den Komponentenbaum weitergibt
| DTO (Data Transfer Object)|Ein schlankes Transportobjekt, das beim Austausch über Schnittstellen nur die benötigten Felder enthält und später ins Domänenmodell gemappt wird
| ServiceContainer|Zentrale Klasse, die alle Services und Adapter einmalig erstellt und per Dependency Injection dem restlichen System bereitstellt
| SecureStore|Expo-Modul, das Schlüssel-Wert-Paare verschlüsselt auf dem Gerät speichert (z. B. Tokens)
| AsyncStorage|Einfacher Key-Value-Speicher von React Native, um Daten lokal persistieren zu können (z. B. für geplantes Offline-Caching)
| JWT (JSON Web Token)|Signiertes Token-Format, das der Client nach dem Login erhält und bei jedem Request im Header mitschickt, damit das Backend den Nutzer identifizieren kann
|===
