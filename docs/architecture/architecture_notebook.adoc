= Architecture Notebook: {project-name}
Laurenz Born <laurenz.born@stud.htw-dresden.de>; Alexander Chlebowski <alexander.chlebowski@stud.htw-dresden.de>; Leonhard Hermann <leonhard.hermann@stud.htw-dresden.de>; Johann Schmidt <johann.schmidt@stud.htw-dresden.de>; Kimi Jerke <kimi.jerke@stud.htw-dresden.de>; Jannes Lehmann <s86317@htw-dresden.de>
{localdatetime}
include::../_includes/default-attributes.inc.adoc[]
// Platzhalter für weitere Dokumenten-Attribute


== Zweck
Dieses Dokument beschreibt die Philosophie, Entscheidungen, Nebenbedingungen, Begründungen, wesentliche Elemente und andere übergreifende Aspekte des Systems, die Einfluss auf Entwurf und Implementierung haben.

//Hinweise: Bearbeiten Sie immer die Abschnitte 2-6 dieser Vorlage. Nachfolgende Abschnitte sind empfohlen, aber optional und sollten je nach Umfang der künftigen Wartungsarbeiten, Fähigkeiten des Entwicklungsteams und Bedeutung anderer architektureller Belange.

//Anmerkung: Die Architektur legt wesentliche EINSCHRÄNKUNGEN für den Systementwurf fest und ist ein Schlüssel für die Erfüllung nicht-funktionaler Eigenschaften!


== Architekturziele 
//Hinweise: Beschreiben Sie den zentralen Ansatz für ihre Architektur. Identifizieren Sie alle Aspekte, die die Philosophie beeinflussen, z.B. komplexe Auslieferung Aspekte, Anpassung von Altsystemen oder besondere Geschwindigkeitsanforderungen. Muss es besonders robust sein, um eine langfristige Wartung und Pflege zu ermöglichen?

//Formulieren Sie eine Reihe von Zielen, die die Architektur in ihrer Struktur und ihrem Verhalten erfüllen muss. Identifizieren Sie kritische Fragen, die von der Architektur adressiert werden müssen, z.B. besondere Hardware-Abhängigkeiten, die vom Rest des Systems isoliert werden sollten oder Sicherstellung der Funktionsfähigkeit unter besonderen Bedingungen (z.B. Offline-Nutzung).

Die Architektur der Habit-Tracking-App verfolgt das Ziel, eine robuste, nutzerfreundliche und wartbare mobile Anwendung bereitzustellen. Sie muss auch unter mobilen Bedingungen zuverlässig funktionieren, idealerweise inklusive Offline-Nutzung, sicherem Umgang mit Nutzerdaten und reibungsloser Benutzererfahrung. Im Fokus stehen dabei folgende zentrale Ziele:

* **Performance**
** *Geringe Latenz bei UI-Interaktionen:* Die App soll möglichst sofort auf Benutzereingaben reagieren, ohne Ruckler beim Scrollen oder Wechseln zwischen Ansichten.
** *Schnelle Ladezeiten:* Daten sollen lokal vorgehalten oder effizient über das Netzwerk geladen werden.

* **Zuverlässigkeit**
** *Robuste Services:* Bei Dienstausfällen auf Serverseite (z. B. Neustarts) darf es nicht zu sehr langfristigen Funktionsverlust kommen.
** *Health-Checks und Rollback:* Wünschenswert wäre, dass das System  bei Inkonsistenzen in Datenbeständen o. ä. automatisch einen Rollback durchführen bzw. diese behebt.

* **Sicherheit**
** *Authentifizierung:* Nutzerregistrierung und -login sollen über ein sicheres Auth-System einerfolgen.
** *Datenverschlüsselung:* Sensible Daten (z. B. persönliche Gewohnheiten) werden sicher gespeichert.
** *Anmeldung & Sessions:* Nutzer bleiben über Sessions angemeldet.

* **Portabilität**
** *Gemeinsame Code-Basis (Android & iOS):* Pflege einer einzigen Codebasis für beide Plattformen. (Auch wenn sich der Fokus im Rahmen des Moduls aus zeitgründen auf der Entwicklung der iOS Version fokussiert)
** *Plattformunabhängige Schnittstellen* 

* **Echtzeit-Updates**
** *Aktuelle Anzeige von Status & Logs:* Änderungen (z. B. „Habit abgehakt“) sollen unmittelbar im UI sichtbar sein – ggf. über Polling oder Push-Ansätze.

//
//* **Offline-Support**
//** *Lokales Caching von Nutzerdaten:* Die App funktioniert auch ohne Internetverbindung, indem Daten lokal zwischengespeichert und später synchronisiert werden.

* **Wartbarkeit**
** *Modularität:* Sauber getrennte Komponenten und Services erleichtern Weiterentwicklung.
** *Dokumentation:* Saubere Schnittstellen und Struktur fördern Problemlösungen bei Fehlern und Ergänzungen leichter zu implementieren. 

* **Skalierbarkeit**
** *Horizontale Skalierung:* bei Nutzerwachstum
** *Effiziente Datenbank* 

//* **Barrierefreiheit**
//** *Kontrast & Schriftgrößen:* App unterstützt Systemeinstellungen für Barrierefreiheit.

//* **Internationalisierung**
//** *Mehrsprachigkeit vorbereitet:* Inhalte können in verschiedene Sprachen übersetz werden.



== Annahmen und Abhängigkeiten
//[List the assumptions and dependencies that drive architectural decisions. This could include sensitive or critical areas, dependencies on legacy interfaces, the skill and experience of the team, the availability of important resources, and so forth]
* Zugriff auf eigenen Server.
* Die App wird als mobile Anwendung umgesetzt, welche iOS (und Android gleichermaßen)  unterstützen soll.
* Die Zielgruppe sind vor allem Einzelpersonen, die persönliche Routinen tracken wollen, eine Mehrbenutzerfähigkeit (z.B. Teams oder Gruppenfunktionen) ist  nicht vorgesehen.
* Die initiale Entwicklung erfolgt durch ein kleines Team mit begrenzter Programmiererfahrung, daher sind einfache Tools, gute Dokumentation und Typsicherheit wichtig.
//* Es ist vorgesehen, dass die App offlinefähig ist mittels lokalem Caching und späterer Synchronisation.
* Datenschutz ist wichtig: DSGVO-Konformität sollte berücksichtigt werden, weshalb persönliche Daten sicher gespeichert werden müssen und auf Wunsch vollständig löschbar sind.
* Benutzerverwaltung und Authentifizierung werden selbst entwickelt.
* Das Backend wird auf einem selbstverwalteten Server betrieben – eigene Datenbank zur Speicherung der Nutzdaten der jeweiligen Nutzer (Fortschritte etc.).
* Die App setzt keine Legacy-Systeme oder bestehende Datenbanken voraus, da es sich um eine Neuentwicklung ohne Altsystem handelt.
* Die geplanten Nutzerzahlen sind zunächst gering, was anfangs keine groß skalierte Architektur und vorallem Serverinfrastruktur voraussetzt. Trotzdem soll die Infastruktur so ausgerichtet sein, dass diese mit steigender Nutzerzahl technisch leicht skalierbar ist.
* Für den Anfang bestehen erstmal keine besonderen Anforderungen an spezielle Hardware-Sensoren oder Hintergrunddienste (z.B. HealthKit, Schrittzähler).  Erweiterungen sind aber technisch denkbar.
* Push-Benachrichtigungen oder Reminder sind im MVP (Minimum Viable Product) vorgesehen.
* Anfängliche Überlegungen zur Nutzung von R für die Erstellung von statisitischen Grafiken wurden aufgrund von Implementierungsaufwand verworfen. 

== Architektur-relevante Anforderungen
//Fügen Sie eine Referenz / Link zu den Anforderungen ein, die implementiert werden müssen, um die Architektur zu erzeugen.

* Das System muss eine persistente Speicherung von Nutzerdaten und Habit-Daten ermöglichen.
* Die Anwendung muss Nutzerregistrierung und -authentifizierung unterstützen.
* Es muss eine sichere Speicherung sensibler Daten (z. B. Passwörter) gewährleistet sein.
* Die Architektur muss eine mobile Anwendung unterstützen.
* Die Lösung muss modular aufgebaut sein, um eine Trennung zwischen Präsentation, Logik und Datenzugriff zu ermöglichen.
* Es muss eine Schnittstelle zur Kommunikation zwischen Frontend und Backend bereitgestellt werden 
* Die Architektur soll wartbar und erweiterbar sein.
//* Die Anwendung muss mehrere Nutzer gleichzeitig unterstützen 

== Entscheidungen, Nebenbedingungen und Begründungen
//[List the decisions that have been made regarding architectural approaches and the constraints being placed on the way that the developers build the system. These will serve as guidelines for defining architecturally significant parts of the system. Justify each decision or constraint so that developers understand the importance of building the system according to the context created by those decisions and constraints. This may include a list of DOs and DON’Ts to guide the developers in building the system.]


=== Frontend-Technologie: Expo (React Native)

*Begründung:* +
- Plattformübergreifende Entwicklung (iOS & Android) mit gemeinsamer Codebasis +
- Live-Testing auf echter Hardware über *Expo Go* per QR-Scan +
- Schnelles Debugging & Hot Reloading +
- Nutzung vertrauter Webtechnologien (JavaScript / TypeScript) +
- Keine macOS-Umgebung notwendig → Entwicklung auf Windows möglich +
- Unterstützt JSON-basierte Konfiguration und lokalen Speicher +

*Nebenbedingung:* +
- Expo-App muss auf Testgeräten installiert sein, um Builds zu starten +
- Komplexe native Module sollten vermieden werden +

---

=== Alternative bewertet: Flutter (Nicht verwendet)

*Begründung für Verwerfung:* +
- Nur virtuelle Testumgebung, kein direkter Test auf physischer Hardware +
- Hoher Speicherverbrauch & Overhead für kleines Projekt +
- Eingeschränkte Drittanbieterbibliotheken +
- Für kleine studentische Teams mit kurzen Iterationszyklen ungeeignet +

---

=== Backend-Technologie: Node.js mit Express

*Begründung:* +
- Einheitliche Sprache (JavaScript) für Frontend & Backend +
- geringere Einarbeitungszeit +
- Bekannte Syntax aus vorherigen Modulen (z. B. EWA) +
- Schnelle Erstellung von REST-Endpunkten +
- Hohe Community-Unterstützung und viele verfügbare Bibliotheken +

*DO:* +
- Standardisierte Routenstruktur (z. B. `/habits`, `/users`, `/achievements`)  

---

=== Datenbank: PostgreSQL (mit Prisma ORM)

*Begründung:* +
- Zuverlässige relationale Datenbank für strukturierte Daten (User, Habits, Achievements) +
- Unterstützt zeitbasierte Abfragen (z.B.: „Habits im letzten Monat“) +
- Prisma ORM bietet Typsicherheit, Migrationen und abstrahiertes Datenbank-Management +
- Vereinfachte Integration mit Express / Node.js +

*Nebenbedingung:* +
- Datenmodelle werden zentral über Prisma-Schema gepflegt +
- Migrationsänderungen dokumentieren und im Repository versionieren +

---

=== Authentifizierung: Firebase Auth (nichtmehr verwendet)


*Begründung für die Entfernung von Firebase Auth:* +
- Aufgrund von Kompatibilitätsproblemen mit der EXPO GO APP unter iOS kann Firebase Auth leider nicht im Rahmen unserer Entwicklung weiter verwendet werden und wurde durch eine eigenes entwickelte Authentifizierungslösung ersetzt.

[.deprecated]
====
*Ursprüngliche Begründung für Nutzung von Firebase Auth:*

*Begründung:*  +
- Sichere und skalierbare Lösung mit minimalem Implementierungsaufwand  +
- Unterstützt 2-Faktor-Authentifizierung, Social Logins und Passwort-Reset +
- Spart Entwicklungszeit, da keine eigene Authentifizierungslogik nötig ist +

*DO:* +
- Firebase Authentication verwenden (inkl. Passwort-Hashing) +

*DON’T:* +
- Passwörter selbst speichern oder eigene Authentifizierung entwickeln +


====
---
=== Internationalisierung (i18next) 

_Status: Geplantes Feature._

*Begründung:* +
- Kompatibel mit React Native +
- Einfache JSON-basierte Übersetzungsstruktur +
- Skalierbar für zukünftige Sprachen und Erweiterungen +

*Nächste Schritte:* +
- i18next-Setup im Presentation-Layer verdrahten +
- Übersetzungsdateien für Deutsch/Englisch anlegen +

---

=== Offline-Funktionalität

_Status: Geplantes Feature – derzeit nur Auth-Tokens werden lokal zwischengespeichert._

*Begründung:* +
- Nutzer sollen Gewohnheiten auch ohne Internetverbindung (z. B. im Flugmodus) erfassen können +
- Verwendung lokaler Speicherung (*AsyncStorage* / JSON) zur Synchronisation mit dem Backend bei Wiederverbindung +
- Stellt sicher, dass Eingaben nicht verloren gehen, wenn kurzfristig keine Verbindung besteht +

*Nächste Schritte:* +
- Persistente Cache-Schicht für Habits & Streaks aufbauen +
- Konfliktauflösungskonzept für spätere Synchronisierung definieren +

---

=== Deployment & Entwicklungsumgebung

*Problem:* +
- Native Entwicklung (Swift/Xcode oder Kotlin/Android Studio) war aufgrund fehlender macOS- bzw. Android-Hardware nicht praktikabel +
- Testen auf echten Geräten wäre nur eingeschränkt möglich +

*Entscheidung:* +
- Nutzung von *Expo* für Frontend-Entwicklung und Testing auf echter Hardware +
- Backend läuft auf bereitgestelltem Windows-Server, wodurch kein lokaler Rechner dauerhaft aktiv sein muss +

*Vorgehensweise:* +
- Express.js-Server aufgesetzt und über *Prisma* an *PostgreSQL* angebunden +
- Kommunikation erfolgt über REST-API +
- *Firebase Auth* war hier ursprünglich vorgesehen, ist aber verworfen (siehe Abschnitt "Authentifizierung") +
- Setup wurde dokumentiert, sodass Teammitglieder es lokal reproduzieren und erweitern +


== Schichten oder Architektur-Framework

Die Codebasis folgt konsequent einer Domain-Driven-Design-Struktur (DDD).

=== Architektur auf einen Blick

[cols="1,2,2",options="header"]
|===
| Layer | Beschreibung | Beispiele
| Presentation Layer | Visualisiert Informationen und ermöglicht Nutzereingaben (UI) | [presentation/controllers/useHabitsController.tsx], [presentation/ui/HabitList.tsx], [app/_layout.tsx]
| Service Layer | Orchestriert Anwendungsabläufe mit Hilfe der Fachobjekte | [application/services/HabitService.ts], [application/services/AuthenticationService.ts]
| Domain Layer | Enthält fachliche Regeln und den Zustand der Geschäftsobjekte | [domain/entities/Habit.ts], [domain/entities/User.ts], [domain/repositories/IHabitsRepository.ts]
| Infrastructure Layer | Liefert technische Basis für Persistenz, Kommunikation und Sicherheit | [infrastructure/adapters/ApiHabitsRepository.ts], [infrastructure/adapters/SecureStoreAuthRepository.ts], [infrastructure/di/ServiceContainer.ts]
|===

=== Ordnerstruktur (Top-Level src/habitree)

----
src/habitree/
├── domain/              # Entitäten + Repository-Schnittstellen
├── application/         # Services
├── infrastructure/      # Adapter + Dependency Injection
├── presentation/        # Provider, Controller-Hooks, UI
├── app/                 # Expo Router Screens
├── context/             # AuthContext & globale Provider
├── constants/, hooks/, styles/, assets/
----

=== Layer-Verantwortlichkeiten im Detail

==== Domänenschicht – domain/
* **entities/** – Enthält alle Fachobjekte wie [/domain/entities/Habit.ts], [/domain/entities/User.ts] oder [/domain/entities/Entry.ts]. Hier werden Berechnungen (z. B. Streak), Validierungen und der Zustand der Geschäftsobjekte definiert.
* **repositories/** – Beinhaltet die Repository-Schnittstellen, etwa [/domain/repositories/IHabitsRepository.ts], [/domain/repositories/IAuthRepository.ts] oder [/domain/repositories/IAchievementRepository.ts]. Diese Interfaces beschreiben, welche Datenzugriffe ein Service benötigt.
* **ports/** – Zusätzliche Schnittstellen zu technischen Diensten wie Benachrichtigungen (siehe [/domain/ports/INotificationPort.ts]). Dient als Erweiterungspunkt für nicht-datenbankbezogene Abhängigkeiten.
* **policies/** – Bündelt fachliche Regeln, die nicht zu einer einzelnen Entity gehören, z. B. [/domain/policies/HabitSchedulePolicy.ts] für Wiederholungslogik und Payload-Validierung vor der Persistenz.
* **Regeln:** Die Domäne importiert ausschließlich Standard-TypeScript, keinerlei Frameworks. HTTP, Persistenz oder UI sind an dieser Stelle unbekannt.

==== Anwendungsschicht (Service Layer) – application/
* **services/** – Enthält Use-Case-spezifische Koordinatoren wie [/application/services/AuthService.ts], [/application/services/HabitService.ts], [/application/services/QuoteService.ts] und [/application/services/ProfileService.ts]. Sie orchestrieren mehrere Ports und kapseln Fehlerbehandlung sowie Domänenlogik.
* **types/** – Gemeinsame Typsammlungen wie [/application/types/ApplicationServices.ts], die der Präsentationsschicht beschreiben, welche Services via DI verfügbar sind.
* **Regeln:** Services sind zustandslos, greifen nur über Interfaces auf Infrastruktur zu und enthalten keine UI-spezifischen Details.

==== Infrastruktur – infrastructure/
* **adapters/** – Technische Implementierungen der Domänenports, etwa [/infrastructure/adapters/ApiHabitsRepository.ts] für REST-Kommunikation oder [/infrastructure/adapters/SecureStoreAuthRepository.ts] für lokale Speicherung. Jeder Adapter kümmert sich um HTTP-Header, Tokenverwaltung, Fehlerbehandlung und wandeln einfache Transportdaten (DTOs) in Domänenobjekte um.
* **di/** – Der ServiceContainer [/infrastructure/di/ServiceContainer.ts] erstellt sämtliche Adapter und Services einmal zentral und stellt sie  der App bereit.
* **Regeln:** Neue externe Systeme (Push, Analytics, weitere Endpoints) landen immer zuerst als Adapter. Nur der Service-Container verdrahtet konkrete Implementierungen mit Interfaces.

==== Präsentationsschicht – presentation/
* **providers/** – Beispielsweise [/presentation/providers/ApplicationServicesProvider.tsx] veröffentlichen die Services im React-Kontext und bilden die Brücke zum Expo Router.
* **controllers/** – Hooks wie [/presentation/controllers/useAuthController.tsx] oder [/presentation/controllers/useHabitsController.tsx] kapseln UI-Status, Loading/Error-Handling und delegieren an die Anwendungsschicht.
* **ui/** – Präsentationskomponenten wie [/presentation/ui/HabitList.tsx], [/presentation/ui/QuoteBanner.tsx] oder generische Bausteine (ThemedView, Collapsible). Sie enthalten keine Geschäftslogik und reagieren ausschließlich auf Props.
* **Regeln:** Keine direkten Infrastrukturimporte; sämtliche Abhängigkeiten werden über `useApplicationServices()` oder Controller-Hooks gedeckt.

==== Expo Router & Kontext – app/, context/
* **app/** – Enthält die Expo-Router-Struktur: Layout ([/app/_layout.tsx]), Auth-Stack ([/app/(auth)/login.tsx]) und Tab-Navigation ([/app/(tabs)/index.tsx]). Jeder Screen nutzt Controller-Hooks, um sich mit der Anwendungsschicht zu verbinden.
* **context/** – Der globale AuthContext ([/context/AuthContext.tsx]) kombiniert `AuthService` mit dem SecureStore-Adapter, speichert Token/User und stellt `signIn/signOut` für alle Screens bereit.
* **Regeln:** `ApplicationServicesProvider` und `AuthProvider` umschließen das gesamte Router-Layout, sodass alle Screens denselben Service-Container nutzen.

=== Arbeitsprinzipien

* Abhängigkeiten verlaufen stets von Präsentation → Anwendung → Domäne; Infrastruktur implementiert nur Schnittstellen der domäne.
* Backend-Endpoints (`/auth`, `/habits`, `/profile`, `/quotes`, `/streaks`, `/achievements`) werden ausschließlich über Infrastrukturadapter adressiert.

=== Feature-Workflow

1. **Domäne:** Entität oder Repository-Schnittstelle ergänzen.
2. **Infrastruktur:** Adapter implementieren.
3. **Anwendung:** Service erweitern und im `ServiceContainer` registrieren.
4. **Präsentation:** Controller-Hook + UI/Screen ergänzen.
5. **Tests:** Unit-Tests für Services, Integrationstests für Adapter, UI-Tests für Komponenten.


== Architektursichten (Views)

Zur besseren Kommunikation und Dokumentation der Architektur werden folgende Sichten genutzt:

* **Kontextsicht:** Darstellung der wichtigsten externen Akteure (z. B. Benutzer) und deren Beziehung zum System. Zeigt, in welchem Umfeld sich die App bewegt.
* **Bausteinsicht:** Zeigt die interne Struktur der Anwendung auf Modulebene – z. B. Trennung von Komponenten, Services, Routen und Datenzugriff.
* **Laufzeitsicht:** Veranschaulicht typische Abläufe wie die Erstellung eines Habits oder das Abrufen von Logs – wichtig zur Analyse von Performance und Nebenläufigkeit.
* **Verteilungssicht:** Zeigt, welche Teile des Systems wo laufen – z. B. Backend auf eigenem Server, Datenbank auf dediziertem Datenbankserver, Frontend auf mobilen Geräten.

Weitere optionale Sichten (nur bei Bedarf):
* **Sicherheitssicht:** Welche Schutzmaßnahmen greifen wo (z. B. Authentifizierung, Datenverschlüsselung)?
* **Entwicklungssicht:** Projektstruktur, CI/CD-Prozesse, Deployment-Pipeline.

=== Kontextabgrenzung
//Level 1 im C4-Modell
image::c4-habitree-level1.png[]
Das C4-Level-1-Diagramm zeigt das Kontextdiagramm der App „Habitreee“, einer Habit-Tracking-App zur Förderung positiver Gewohnheiten. Es stellt die wichtigsten Stakeholder, deren Rollen sowie deren Beziehungen zum System und zur Projektgruppe dar.


=== Container
//Level 2 im C4-Modell
image::C4-level2.png[]
Das C4-Level-2-Container-Diagramm zeigt die technische Struktur der Habitreee-Anwendung auf Container-Ebene.

* Die Mobile App, das Frontend programmiert mit React Native, wird direkt von den Studierenden genutzt
* Das Backend basiert auf Node.js mit Express und läuft auf einem externen Server der Hochschule
* Zur Nutzer-Authentifizierung wird auf das Backend zugegriffen.
* Prisma ORM dient als Vermittler zwischen dem Backend und der PostgreSQL-Datenbank, in der Nutzerdaten und Gewohnheiten gespeichert werden
* Die Kommunikation zwischen Frontend und Backend erfolgt über eine REST API
=== Components
//Level 3 im C4-Modell


=== Verteilungsdiagramm (Deployment Diagramm)
//Beschreibt die physischen Knoten (Rechner) des Systems und Komponenten, die in diesen Knoten ausgeführt werden. Diese Sicht wird nicht benötigt, wenn das System in einem einzelnen Prozess oder Thread ausgeführt wird.
image::deployment-diagram-habitree.svg[]

== Glossar für technische Fachbegriffe
[%header]
|===
| Begriff | Definition/Erläuterung 
| Emulator | Ein Emulator ist eine Software, die auf einem Computer die Hardware und das Betriebssystem eines anderen Geräts nachahmt, um darauf Programme auszuführen.
| XCode |  integrierte Entwicklungsumgebung (IDE) von Apple zum Programmieren, Testen und Veröffentlichen von Apps für iOS, macOS, watchOS und tvOS.
| Swift | Programmiersprache zur Erstellung von Apps für iOS, macOS, watchOS und tvOS.
| Flutter | Flutter ist ein Open-Source-Framework von Google zur Entwicklung plattformübergreifender Apps für iOS, Android, Web und Desktop mit einer einzigen Codebasis in der Programmiersprache Dart.
| React Native | Framework zur Entwciklung von mobilen Applikationen für IOS und Android
| Expo | open source Platform für die entwicklung nativer apps für Andoiid, IOS und Web auf einer Codebasis in der Programmiersprache Typescript
| Expo Go | App auf mobilen Endgerät zur darstellung des entwickeltem Projects
| Ausfallzeit (engl.: Downtime)
| Zeitspanne, in der System nicht verfügbar oder funktionsfähig ist.  +
Kann verursacht werden Beispielsweise durch:  +
- Serverprobleme  +
- Bugs  +
- Wartung   
| Lightmode bzw. Darkmode 
| Darstellungsmodus einer Anwendung mit heller bzw. dunkler Benutzeroberfläche, meisten mit dunklen bzw. hellen Text auf hellen bzw. dunklen Hintergrund.  +
Das Ziel des Lightmodes ist es den Nutzer ein angenehmes feeling auch bei Tageslicht zu geben.  +
Die  Ziele des Darmodes sind primär die Entlastung der Augen und die Erhöhung der Energieeffizienz.
|Backend| Der Teil einer Anwendung, der auf dem Server läuft und Daten verarbeitet
|Frontend| Die Benutzeroberfläche einer Anwendung, die im Browser oder auf dem Gerät sichtbar ist
|API| Eine Schnittstelle, die den Datenaustausch zwischen verschiedenen Softwarekomponenten ermöglicht
|ORM|  Ein Werkzeug, das Datenbanktabellen in Programmiersprachenobjekte übersetzt und deren Nutzung vereinfacht
|Relationale Datenbank|  Eine Datenbank, die Daten in Tabellen mit Beziehungen zueinander speichert
|Framework| Ein vorgefertigtes Softwaregerüst, das Entwicklern beim Erstellen von Anwendungen hilft
|MVP (Minimum Viable Product)|Minimal umsetzbare Produktversion mit Kernfunktionen zur Validierung des Konzepts
|Domain-Driven Design (DDD)|Architekturstil, der Geschäftslogik in Domänenmodell, Anwendung, Infrastruktur und Präsentation trennt und Fachsprache mit Code synchron hält
|Repository|Abstraktion des Datenzugriffs, die Entitäten unabhängig von konkreten Speichertechnologien bereitstellt
|Port|Schnittstelle zu externen Diensten (z. B. Notifications), damit die Domäne keine technischen Details kennen muss
|Policy|Bündelt fachliche Regeln, die nicht zu einer einzelnen Entität gehören, etwa Zeit- oder Wiederholungslogik
|Adapter|Konkrete Implementierung eines Ports, die HTTP, lokale Speicherung oder andere Technik mit der Domäne verbindet
|Dependency Injection (DI)|Muster, bei dem Abhängigkeiten von außen bereitgestellt werden, um Code testbar und entkoppelt zu halten
|Composition Root|Zentraler Ort (z. B. ServiceContainer), an dem alle konkreten Implementierungen registriert und miteinander verdrahtet werden
|Expo Router|Dateibasiertes Routing-System von Expo/React Native zur Strukturierung von Screens, Layouts und Navigations-Stacks
|Controller-Hook|Präsentationsspezifischer Hook, der UI-Zustand, Validierung und Service-Aufrufe kapselt
|Provider|React-Komponente, die Werte oder Services über Context an den Komponentenbaum weitergibt
| DTO (Data Transfer Object)|Ein schlankes Transportobjekt, das beim Austausch über Schnittstellen nur die benötigten Felder enthält und später ins Domänenmodell gemappt wird
| ServiceContainer|Zentrale Klasse, die alle Services und Adapter einmalig erstellt und per Dependency Injection dem restlichen System bereitstellt
| SecureStore|Expo-Modul, das Schlüssel-Wert-Paare verschlüsselt auf dem Gerät speichert (z. B. Tokens)
| AsyncStorage|Einfacher Key-Value-Speicher von React Native, um Daten lokal persistieren zu können (z. B. für geplantes Offline-Caching)
|===
